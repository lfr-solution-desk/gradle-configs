import groovy.transform.Immutable

// The minimal configuration to get all the Gradle modules publishes in GitHub Packages repository
// (as Maven artifacts), defaulting to using Solution Desk GitHub organization as the target of the packages.
// The to be applied from Liferay Workspace -> build.gradle

// For documentation of the input properties, see 'src/gradle/gpr/gradle.properties'

buildscript {
    repositories { jcenter() }
    dependencies {
        classpath 'com.netflix.nebula:nebula-publishing-plugin:17.2.1'
    }
}

// TODO we could even probably deduce the repo's name from 'git' info (grgit plugin or something) if needed,
//  but I think it's fine to take this from Gradle
final String githubRepoOwner = project.findProperty('liferay.gpr.publishing.repo.owner') ?: 'lfr-solution-desk'
final String githubRepoName = project.findProperty('liferay.gpr.publishing.repo.name') ?: rootProject.name

final String publicationType = project.findProperty('liferay.gpr.publishing.type') ?: 'SNAPSHOT'
assert publicationType in [ 'RELEASE', 'SNAPSHOT' ], "Please use either RELEASE or SNAPSHOT for 'liferay.gpr.publishing.type'."

final String groupIdTemplate =
        project.findProperty('liferay.gpr.publishing.groupid.template') ?: 'com.liferay.soldesk.${rootProjectName}'
final String artifactIdTemplate =
        project.findProperty('liferay.gpr.publishing.artifactid.template') ?: 'com.liferay.soldesk.${rootProjectName}.${projectName}'
final String versionSource = project.findProperty('liferay.gpr.publishing.version.source') ?: 'GRADLE_ROOT_PROJECT'
assert versionSource in [ 'GRADLE_ROOT_PROJECT', 'GRADLE_PROJECT' ], "Please use GRADLE_ROOT_PROJECT or GRADLE_PROJECT for 'liferay.gpr.publishing.version.source'."

final boolean publishSourcesDefault = (project.findProperty('liferay.gpr.publishing.sources.published') ?: 'true').toString().toBoolean()
final boolean publishJavadocDefault = (project.findProperty('liferay.gpr.publishing.javadoc.published') ?: 'true').toString().toBoolean()


final def resolveIdTemplate = { String template, Project moduleProject ->
    def binding = [
            rootProjectName: moduleProject.rootProject.name,
            projectGroup   : moduleProject.group,
            projectName    : moduleProject.name
    ]
    return new groovy.text.SimpleTemplateEngine().createTemplate(template).make(binding).toString()
}

final def resolveGroupIdTemplate = resolveIdTemplate.curry(groupIdTemplate)
final def resolveArtifactIdTemplate = resolveIdTemplate.curry(artifactIdTemplate)


gradle.taskGraph.whenReady { TaskExecutionGraph tg ->
    // Make the GPR auth properties mandatory, since credentials for GPR will always be required when publishing
    if(tg.allTasks.find { it.name == 'publishNebulaPublicationToGitHubPackagesRepository' }) {
        if(!findProperty('liferay.gpr.publishing.actor') || !findProperty('liferay.gpr.publishing.token')) {
            throw new InvalidUserDataException(
                    "The project properties with auth for GitHub Packages publishing ('liferay.gpr.publishing.actor' and " +
                            "'liferay.gpr.publishing.token') are required when publishing, but were not provided.")
        }
    }
}

logger.info """[gpr] githubRepoOwner= ${githubRepoOwner} | githubRepoName= ${githubRepoName} | publicationType= ${publicationType} | \
groupIdTemplate= ${groupIdTemplate} | artifactIdTemplate= ${artifactIdTemplate} | \
publishSourcesDefault= ${publishSourcesDefault} | publishJavadocDefault= ${publishJavadocDefault}"""


class GprExtension {
    // The desired custom identity, if it should be different from the 'liferay.gpr.publishing.*' templates
    String groupId
    String artifactId

    // what gets published, if custom
    boolean publishSources
    boolean publishJavadoc
}

// The root one, will depend on the "extra" verification we define for individual subproject;
// that way, all verifications (on any subproject) will be run first, only then any actual publication
tasks.register('verifyPublication')

subprojects {

    // https://help.github.com/en/packages/using-github-packages-with-your-projects-ecosystem/configuring-gradle-for-use-with-github-packages
    // https://docs.gradle.org/5.6.4/userguide/publishing_maven.html#sec:publishing_custom_artifacts_to_maven
    // https://github.com/nebula-plugins/nebula-publishing-plugin

    // The extension on each Gradle project, which can be used to customize the publication of one particular project
    project.extensions.create('gpr', GprExtension)
    project.gpr {
        publishSources = publishSourcesDefault
        publishJavadoc = publishJavadocDefault
    }

    if (!project.childProjects) {
        apply plugin: nebula.plugin.publishing.maven.MavenPublishPlugin
        apply plugin: nebula.plugin.publishing.verification.PublishVerificationPlugin

        apply plugin: nebula.plugin.publishing.publications.SourceJarPlugin

        // TODO an error is thrown when not using Gradle 6+:
        //  Could not find method withJavadocJar() for arguments [] on object of type org.gradle.api.plugins.internal.DefaultJavaPluginExtension
        //                apply plugin: nebula.plugin.publishing.publications.JavadocJarPlugin

        // Use the legacy option to set up the publication of javadoc instead
        project.pluginManager.withPlugin('java') {
            task javadocJar(type: Jar) {
                from javadoc
                archiveClassifier = 'javadoc'
            }

            publishing.publications.nebula(MavenPublication) {
                artifact javadocJar
            }
        }

        // The target Maven repository to publish into
        publishing {
            repositories {
                maven {
                    name = "GitHubPackages"
                    url = uri("https://maven.pkg.github.com/${githubRepoOwner}/${githubRepoName}")
                    credentials {
                        username project.findProperty('liferay.gpr.publishing.actor')
                        password project.findProperty('liferay.gpr.publishing.token')
                    }
                }
            }
        }

        project.afterEvaluate {
            // Projects inside "themes" directory might have no "war" plugin applied, so only POM would be published =>
            // add the WAR built with the use of NPM manually
            PublishArtifact npmThemeWarArtifact

            if (project.path.startsWith(":themes:") && !project.plugins.hasPlugin(WarPlugin)) {
                // https://github.com/liferay/liferay-portal/blob/master/modules/sdk/gradle-plugins-workspace/src/main/java/com/liferay/gradle/plugins/workspace/configurators/ThemesProjectConfigurator.java#L236
                // def warFile = project.file("dist/${project.getConvention().getPlugin(BasePluginConvention).archivesBaseName}.war")
                def warFile = project.file("dist/${project.name}.war")
                def builtByTask = 'gulpBuild'

                // We need to create a custom configuration and add the artifact to it
                project.configurations { liferayThemeWar }
                npmThemeWarArtifact = project.artifacts.add('liferayThemeWar', warFile) {
                    type 'war'
                    builtBy builtByTask
                }

                logger.info "[gpr] ${project} has no WAR plugin applied, created a custom artifact to publish -- " +
                        "from file '${rootProject.relativePath(npmThemeWarArtifact.file)}', built by '${builtByTask}'"
            }

            // The published identity for the project; either the one users provided via 'project.gpr' extension,
            // or the one based on the templates
            publishing {
                publications {
                    nebula(MavenPublication) {
                        groupId = project.gpr.groupId ?: resolveGroupIdTemplate(project)
                        artifactId = project.gpr.artifactId ?: resolveArtifactIdTemplate(project)

                        // Only override the version if taking it from root project, otherwise leave as is ~ based on project
                        if (versionSource == 'GRADLE_ROOT_PROJECT') {
                            version = project.rootProject.version
                        }

                        // add the theme's war built by NPM, if such artifact will be created
                        // (= this project is a theme and is built by NPM, see above)
                        if (npmThemeWarArtifact) {
                            artifact npmThemeWarArtifact
                        }

                        pom {
                            scm {
                                connection = "scm:git:https://github.com/${githubRepoOwner}/${githubRepoName}.git"
                                developerConnection = "scm:git:https://github.com/${githubRepoOwner}/${githubRepoName}.git"
                                url = "https://github.com/${githubRepoOwner}/${githubRepoName}"
                            }
                        }
                    }
                }
            }

            if (publicationType == 'SNAPSHOT') {
                // force the -SNAPSHOT version in the pom.xml if publishing a SNAPSHOT
                publishing.publications.nebula(MavenPublication) { MavenPublication pub ->
                    if (!pub.version.endsWith('-SNAPSHOT')) {
                        pub.version "${pub.version}-SNAPSHOT"
                    }
                }
            } else if (publicationType == 'RELEASE') {
                // nothing for now
            }

            // once the subproject is evaluated, determine if the -sources and -javadoc
            // actually should be published, since users can customize this per subproject
            // via the 'gpr' extension on every project
            [
                    'javadoc': project.gpr.publishJavadoc,
                    'sources': project.gpr.publishSources,
            ].each { String artifactClassifier, boolean shouldBePublished ->
                if (!shouldBePublished || publicationType == 'SNAPSHOT') {
                    publishing.publications.nebula(MavenPublication).artifacts.with { MavenArtifactSet mas ->
                        mas.remove(mas.find { it.classifier == artifactClassifier })
                    }

                    if (!shouldBePublished) {
                        logger.info "[gpr] '${artifactClassifier}' should not be published nased on project.gpr extension => " +
                                "removed from the list of published artifacts: ${publishing.publications.nebula(MavenPublication).artifacts}"
                    } else {
                        logger.info "[gpr] The '${artifactClassifier}' artifact for ${project} won't get published, " +
                                "because of limitation of GitHub Packages repo for SNAPSHOT artifacts."
                    }
                }
            }
        }

        // verifyPublication (added by nebula.plugin.publishing.verification.PublishVerificationPlugin)
        // only applied on Java projects and only during afterEvaluate
        def verifyPublicationForSubproject = tasks.findByName('verifyPublication')

        if (verifyPublicationForSubproject) {
            rootProject.tasks.findByName('verifyPublication').configure {
                dependsOn verifyPublicationForSubproject
            }
        }

        def verifyPublishingTypeMatchesVersion = tasks.register('verifyPublishingTypeMatchesVersion') {
            doLast {
                assert !(publicationType == 'RELEASE' && publishing.publications.nebula(MavenPublication).version.endsWith('-SNAPSHOT'))
            }
        }

        def verifyNotAlreadyPublishedToRemoteRepo = tasks.register('verifyNotAlreadyPublishedToRemoteRepo') {
            def targetRepoName = 'GitHubPackages'

            doLast {
                String groupId = publishing.publications.nebula.groupId
                String artifactId = publishing.publications.nebula.artifactId
                String version = publishing.publications.nebula.version
                String extension = publishing.publications.nebula.pom.packaging

                if (!version.endsWith('-SNAPSHOT')) {
                    publishing.repositories.getByName(targetRepoName).with { MavenArtifactRepository mar ->
                        def primaryArtifactUrl =
                                "${mar.url}/${groupId.replace('.', '/')}/${artifactId}/${version}/${artifactId}-${version}.${extension}"

                        println "[gpr] TODO need to check the response for this URL: ${primaryArtifactUrl}"

                        // TODO implement fetching the URL, need to pass credetials in the HTTP request as well
                        // 200 => already published
                        // 404 => not published
                    }
                } else {
                    logger.info "[gpr] A SNAPSHOT artifact will be published, assuming these can always be re-published."
                }
            }
        }

        def checkNoSnapshotDependenciesUsed = tasks.register('checkNoSnapshotDependenciesUsed') {
            doLast {
                String version = publishing.publications.nebula.version

                if (!version.endsWith('-SNAPSHOT')) {
                    def dependenciesWithSnapshotVersionByConfiguration =
                            configurations.collectEntries() { Configuration c ->
                                [ c, c.allDependencies.findAll { Dependency  d -> (d.version ?: '').endsWith('-SNAPSHOT') } ]
                            }.findAll {
                                Configuration c, Set<Dependency> directDependenciesHavingSnapshotVersion ->
                                    !directDependenciesHavingSnapshotVersion.isEmpty()
                            }

                    if (!dependenciesWithSnapshotVersionByConfiguration.isEmpty()) {
                        throw new InvalidUserDataException(
                                "The module ${project} is about to be published with final version '${version}' while " +
                                "using one or more -SNAPSHOT dependencies. Please make all dependencies final first. " +
                                "Configurations and their offending dependencies: ${dependenciesWithSnapshotVersionByConfiguration}")
                    }
                } else {
                    logger.info "[gpr] A SNAPSHOT artifact will be published, assuming these can have SNAPSHOTs as dependencies."
                }
            }
        }

        tasks.findByPath(':verifyPublication').configure {
            dependsOn verifyPublishingTypeMatchesVersion
            dependsOn checkNoSnapshotDependenciesUsed
            dependsOn verifyNotAlreadyPublishedToRemoteRepo
        }
    }
}